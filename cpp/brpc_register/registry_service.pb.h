// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: registry_service.proto

#ifndef PROTOBUF_INCLUDED_registry_5fservice_2eproto
#define PROTOBUF_INCLUDED_registry_5fservice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_registry_5fservice_2eproto 

namespace protobuf_registry_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_registry_5fservice_2eproto
namespace registry {
class DiscoverRequest;
class DiscoverRequestDefaultTypeInternal;
extern DiscoverRequestDefaultTypeInternal _DiscoverRequest_default_instance_;
class DiscoverResponse;
class DiscoverResponseDefaultTypeInternal;
extern DiscoverResponseDefaultTypeInternal _DiscoverResponse_default_instance_;
class HeartbeatRequest;
class HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
class HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class ServerAddress;
class ServerAddressDefaultTypeInternal;
extern ServerAddressDefaultTypeInternal _ServerAddress_default_instance_;
class UnregisterRequest;
class UnregisterRequestDefaultTypeInternal;
extern UnregisterRequestDefaultTypeInternal _UnregisterRequest_default_instance_;
class UnregisterResponse;
class UnregisterResponseDefaultTypeInternal;
extern UnregisterResponseDefaultTypeInternal _UnregisterResponse_default_instance_;
}  // namespace registry
namespace google {
namespace protobuf {
template<> ::registry::DiscoverRequest* Arena::CreateMaybeMessage<::registry::DiscoverRequest>(Arena*);
template<> ::registry::DiscoverResponse* Arena::CreateMaybeMessage<::registry::DiscoverResponse>(Arena*);
template<> ::registry::HeartbeatRequest* Arena::CreateMaybeMessage<::registry::HeartbeatRequest>(Arena*);
template<> ::registry::HeartbeatResponse* Arena::CreateMaybeMessage<::registry::HeartbeatResponse>(Arena*);
template<> ::registry::RegisterRequest* Arena::CreateMaybeMessage<::registry::RegisterRequest>(Arena*);
template<> ::registry::RegisterResponse* Arena::CreateMaybeMessage<::registry::RegisterResponse>(Arena*);
template<> ::registry::ServerAddress* Arena::CreateMaybeMessage<::registry::ServerAddress>(Arena*);
template<> ::registry::UnregisterRequest* Arena::CreateMaybeMessage<::registry::UnregisterRequest>(Arena*);
template<> ::registry::UnregisterResponse* Arena::CreateMaybeMessage<::registry::UnregisterResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace registry {

enum RegisterResponse_Status {
  RegisterResponse_Status_SUCCESS = 0,
  RegisterResponse_Status_INVALID_PARAM = 1,
  RegisterResponse_Status_ALREADY_EXISTS = 2
};
bool RegisterResponse_Status_IsValid(int value);
const RegisterResponse_Status RegisterResponse_Status_Status_MIN = RegisterResponse_Status_SUCCESS;
const RegisterResponse_Status RegisterResponse_Status_Status_MAX = RegisterResponse_Status_ALREADY_EXISTS;
const int RegisterResponse_Status_Status_ARRAYSIZE = RegisterResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* RegisterResponse_Status_descriptor();
inline const ::std::string& RegisterResponse_Status_Name(RegisterResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    RegisterResponse_Status_descriptor(), value);
}
inline bool RegisterResponse_Status_Parse(
    const ::std::string& name, RegisterResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterResponse_Status>(
    RegisterResponse_Status_descriptor(), name, value);
}
enum UnregisterResponse_Status {
  UnregisterResponse_Status_SUCCESS = 0,
  UnregisterResponse_Status_NOT_FOUND = 1
};
bool UnregisterResponse_Status_IsValid(int value);
const UnregisterResponse_Status UnregisterResponse_Status_Status_MIN = UnregisterResponse_Status_SUCCESS;
const UnregisterResponse_Status UnregisterResponse_Status_Status_MAX = UnregisterResponse_Status_NOT_FOUND;
const int UnregisterResponse_Status_Status_ARRAYSIZE = UnregisterResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnregisterResponse_Status_descriptor();
inline const ::std::string& UnregisterResponse_Status_Name(UnregisterResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnregisterResponse_Status_descriptor(), value);
}
inline bool UnregisterResponse_Status_Parse(
    const ::std::string& name, UnregisterResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnregisterResponse_Status>(
    UnregisterResponse_Status_descriptor(), name, value);
}
enum HeartbeatResponse_Status {
  HeartbeatResponse_Status_SUCCESS = 0,
  HeartbeatResponse_Status_NOT_REGISTERED = 1
};
bool HeartbeatResponse_Status_IsValid(int value);
const HeartbeatResponse_Status HeartbeatResponse_Status_Status_MIN = HeartbeatResponse_Status_SUCCESS;
const HeartbeatResponse_Status HeartbeatResponse_Status_Status_MAX = HeartbeatResponse_Status_NOT_REGISTERED;
const int HeartbeatResponse_Status_Status_ARRAYSIZE = HeartbeatResponse_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* HeartbeatResponse_Status_descriptor();
inline const ::std::string& HeartbeatResponse_Status_Name(HeartbeatResponse_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    HeartbeatResponse_Status_descriptor(), value);
}
inline bool HeartbeatResponse_Status_Parse(
    const ::std::string& name, HeartbeatResponse_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HeartbeatResponse_Status>(
    HeartbeatResponse_Status_descriptor(), name, value);
}
// ===================================================================

class ServerAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.ServerAddress) */ {
 public:
  ServerAddress();
  virtual ~ServerAddress();

  ServerAddress(const ServerAddress& from);

  inline ServerAddress& operator=(const ServerAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerAddress(ServerAddress&& from) noexcept
    : ServerAddress() {
    *this = ::std::move(from);
  }

  inline ServerAddress& operator=(ServerAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerAddress* internal_default_instance() {
    return reinterpret_cast<const ServerAddress*>(
               &_ServerAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ServerAddress* other);
  friend void swap(ServerAddress& a, ServerAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerAddress* New() const final {
    return CreateMaybeMessage<ServerAddress>(NULL);
  }

  ServerAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerAddress& from);
  void MergeFrom(const ServerAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // optional int32 weight = 3;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 3;
  ::google::protobuf::int32 weight() const;
  void set_weight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:registry.ServerAddress)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_weight();
  void clear_has_weight();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 weight_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterRequest>(NULL);
  }

  RegisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  bool has_service_name() const;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // required .registry.ServerAddress address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  private:
  const ::registry::ServerAddress& _internal_address() const;
  public:
  const ::registry::ServerAddress& address() const;
  ::registry::ServerAddress* release_address();
  ::registry::ServerAddress* mutable_address();
  void set_allocated_address(::registry::ServerAddress* address);

  // @@protoc_insertion_point(class_scope:registry.RegisterRequest)
 private:
  void set_has_service_name();
  void clear_has_service_name();
  void set_has_address();
  void clear_has_address();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::registry::ServerAddress* address_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(NULL);
  }

  RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RegisterResponse_Status Status;
  static const Status SUCCESS =
    RegisterResponse_Status_SUCCESS;
  static const Status INVALID_PARAM =
    RegisterResponse_Status_INVALID_PARAM;
  static const Status ALREADY_EXISTS =
    RegisterResponse_Status_ALREADY_EXISTS;
  static inline bool Status_IsValid(int value) {
    return RegisterResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    RegisterResponse_Status_Status_MIN;
  static const Status Status_MAX =
    RegisterResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    RegisterResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return RegisterResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return RegisterResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return RegisterResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required .registry.RegisterResponse.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::registry::RegisterResponse_Status status() const;
  void set_status(::registry::RegisterResponse_Status value);

  // @@protoc_insertion_point(class_scope:registry.RegisterResponse)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int status_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnregisterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.UnregisterRequest) */ {
 public:
  UnregisterRequest();
  virtual ~UnregisterRequest();

  UnregisterRequest(const UnregisterRequest& from);

  inline UnregisterRequest& operator=(const UnregisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnregisterRequest(UnregisterRequest&& from) noexcept
    : UnregisterRequest() {
    *this = ::std::move(from);
  }

  inline UnregisterRequest& operator=(UnregisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnregisterRequest* internal_default_instance() {
    return reinterpret_cast<const UnregisterRequest*>(
               &_UnregisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(UnregisterRequest* other);
  friend void swap(UnregisterRequest& a, UnregisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnregisterRequest* New() const final {
    return CreateMaybeMessage<UnregisterRequest>(NULL);
  }

  UnregisterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnregisterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnregisterRequest& from);
  void MergeFrom(const UnregisterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  bool has_service_name() const;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // required .registry.ServerAddress address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  private:
  const ::registry::ServerAddress& _internal_address() const;
  public:
  const ::registry::ServerAddress& address() const;
  ::registry::ServerAddress* release_address();
  ::registry::ServerAddress* mutable_address();
  void set_allocated_address(::registry::ServerAddress* address);

  // @@protoc_insertion_point(class_scope:registry.UnregisterRequest)
 private:
  void set_has_service_name();
  void clear_has_service_name();
  void set_has_address();
  void clear_has_address();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::registry::ServerAddress* address_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnregisterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.UnregisterResponse) */ {
 public:
  UnregisterResponse();
  virtual ~UnregisterResponse();

  UnregisterResponse(const UnregisterResponse& from);

  inline UnregisterResponse& operator=(const UnregisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnregisterResponse(UnregisterResponse&& from) noexcept
    : UnregisterResponse() {
    *this = ::std::move(from);
  }

  inline UnregisterResponse& operator=(UnregisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnregisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnregisterResponse* internal_default_instance() {
    return reinterpret_cast<const UnregisterResponse*>(
               &_UnregisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UnregisterResponse* other);
  friend void swap(UnregisterResponse& a, UnregisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnregisterResponse* New() const final {
    return CreateMaybeMessage<UnregisterResponse>(NULL);
  }

  UnregisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnregisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnregisterResponse& from);
  void MergeFrom(const UnregisterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnregisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UnregisterResponse_Status Status;
  static const Status SUCCESS =
    UnregisterResponse_Status_SUCCESS;
  static const Status NOT_FOUND =
    UnregisterResponse_Status_NOT_FOUND;
  static inline bool Status_IsValid(int value) {
    return UnregisterResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    UnregisterResponse_Status_Status_MIN;
  static const Status Status_MAX =
    UnregisterResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    UnregisterResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return UnregisterResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return UnregisterResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return UnregisterResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .registry.UnregisterResponse.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::registry::UnregisterResponse_Status status() const;
  void set_status(::registry::UnregisterResponse_Status value);

  // @@protoc_insertion_point(class_scope:registry.UnregisterResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiscoverRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.DiscoverRequest) */ {
 public:
  DiscoverRequest();
  virtual ~DiscoverRequest();

  DiscoverRequest(const DiscoverRequest& from);

  inline DiscoverRequest& operator=(const DiscoverRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoverRequest(DiscoverRequest&& from) noexcept
    : DiscoverRequest() {
    *this = ::std::move(from);
  }

  inline DiscoverRequest& operator=(DiscoverRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoverRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoverRequest* internal_default_instance() {
    return reinterpret_cast<const DiscoverRequest*>(
               &_DiscoverRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(DiscoverRequest* other);
  friend void swap(DiscoverRequest& a, DiscoverRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoverRequest* New() const final {
    return CreateMaybeMessage<DiscoverRequest>(NULL);
  }

  DiscoverRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscoverRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscoverRequest& from);
  void MergeFrom(const DiscoverRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoverRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  bool has_service_name() const;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:registry.DiscoverRequest)
 private:
  void set_has_service_name();
  void clear_has_service_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiscoverResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.DiscoverResponse) */ {
 public:
  DiscoverResponse();
  virtual ~DiscoverResponse();

  DiscoverResponse(const DiscoverResponse& from);

  inline DiscoverResponse& operator=(const DiscoverResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoverResponse(DiscoverResponse&& from) noexcept
    : DiscoverResponse() {
    *this = ::std::move(from);
  }

  inline DiscoverResponse& operator=(DiscoverResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoverResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoverResponse* internal_default_instance() {
    return reinterpret_cast<const DiscoverResponse*>(
               &_DiscoverResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(DiscoverResponse* other);
  friend void swap(DiscoverResponse& a, DiscoverResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoverResponse* New() const final {
    return CreateMaybeMessage<DiscoverResponse>(NULL);
  }

  DiscoverResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DiscoverResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DiscoverResponse& from);
  void MergeFrom(const DiscoverResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiscoverResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .registry.ServerAddress addresses = 1;
  int addresses_size() const;
  void clear_addresses();
  static const int kAddressesFieldNumber = 1;
  ::registry::ServerAddress* mutable_addresses(int index);
  ::google::protobuf::RepeatedPtrField< ::registry::ServerAddress >*
      mutable_addresses();
  const ::registry::ServerAddress& addresses(int index) const;
  ::registry::ServerAddress* add_addresses();
  const ::google::protobuf::RepeatedPtrField< ::registry::ServerAddress >&
      addresses() const;

  // @@protoc_insertion_point(class_scope:registry.DiscoverResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::registry::ServerAddress > addresses_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.HeartbeatRequest) */ {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();

  HeartbeatRequest(const HeartbeatRequest& from);

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(HeartbeatRequest* other);
  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatRequest* New() const final {
    return CreateMaybeMessage<HeartbeatRequest>(NULL);
  }

  HeartbeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service_name = 1;
  bool has_service_name() const;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  #if LANG_CXX11
  void set_service_name(::std::string&& value);
  #endif
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // required .registry.ServerAddress address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  private:
  const ::registry::ServerAddress& _internal_address() const;
  public:
  const ::registry::ServerAddress& address() const;
  ::registry::ServerAddress* release_address();
  ::registry::ServerAddress* mutable_address();
  void set_allocated_address(::registry::ServerAddress* address);

  // @@protoc_insertion_point(class_scope:registry.HeartbeatRequest)
 private:
  void set_has_service_name();
  void clear_has_service_name();
  void set_has_address();
  void clear_has_address();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  ::registry::ServerAddress* address_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:registry.HeartbeatResponse) */ {
 public:
  HeartbeatResponse();
  virtual ~HeartbeatResponse();

  HeartbeatResponse(const HeartbeatResponse& from);

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(HeartbeatResponse* other);
  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatResponse* New() const final {
    return CreateMaybeMessage<HeartbeatResponse>(NULL);
  }

  HeartbeatResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HeartbeatResponse_Status Status;
  static const Status SUCCESS =
    HeartbeatResponse_Status_SUCCESS;
  static const Status NOT_REGISTERED =
    HeartbeatResponse_Status_NOT_REGISTERED;
  static inline bool Status_IsValid(int value) {
    return HeartbeatResponse_Status_IsValid(value);
  }
  static const Status Status_MIN =
    HeartbeatResponse_Status_Status_MIN;
  static const Status Status_MAX =
    HeartbeatResponse_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    HeartbeatResponse_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return HeartbeatResponse_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return HeartbeatResponse_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return HeartbeatResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .registry.HeartbeatResponse.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::registry::HeartbeatResponse_Status status() const;
  void set_status(::registry::HeartbeatResponse_Status value);

  // @@protoc_insertion_point(class_scope:registry.HeartbeatResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::protobuf_registry_5fservice_2eproto::TableStruct;
};
// ===================================================================

class RegistryService_Stub;

class RegistryService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline RegistryService() {};
 public:
  virtual ~RegistryService();

  typedef RegistryService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void Register(::google::protobuf::RpcController* controller,
                       const ::registry::RegisterRequest* request,
                       ::registry::RegisterResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void Unregister(::google::protobuf::RpcController* controller,
                       const ::registry::UnregisterRequest* request,
                       ::registry::UnregisterResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void Discover(::google::protobuf::RpcController* controller,
                       const ::registry::DiscoverRequest* request,
                       ::registry::DiscoverResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void Heartbeat(::google::protobuf::RpcController* controller,
                       const ::registry::HeartbeatRequest* request,
                       ::registry::HeartbeatResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RegistryService);
};

class RegistryService_Stub : public RegistryService {
 public:
  RegistryService_Stub(::google::protobuf::RpcChannel* channel);
  RegistryService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~RegistryService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements RegistryService ------------------------------------------

  void Register(::google::protobuf::RpcController* controller,
                       const ::registry::RegisterRequest* request,
                       ::registry::RegisterResponse* response,
                       ::google::protobuf::Closure* done);
  void Unregister(::google::protobuf::RpcController* controller,
                       const ::registry::UnregisterRequest* request,
                       ::registry::UnregisterResponse* response,
                       ::google::protobuf::Closure* done);
  void Discover(::google::protobuf::RpcController* controller,
                       const ::registry::DiscoverRequest* request,
                       ::registry::DiscoverResponse* response,
                       ::google::protobuf::Closure* done);
  void Heartbeat(::google::protobuf::RpcController* controller,
                       const ::registry::HeartbeatRequest* request,
                       ::registry::HeartbeatResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RegistryService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ServerAddress

// required string ip = 1;
inline bool ServerAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerAddress::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ServerAddress::ip() const {
  // @@protoc_insertion_point(field_get:registry.ServerAddress.ip)
  return ip_.GetNoArena();
}
inline void ServerAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:registry.ServerAddress.ip)
}
#if LANG_CXX11
inline void ServerAddress::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:registry.ServerAddress.ip)
}
#endif
inline void ServerAddress::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:registry.ServerAddress.ip)
}
inline void ServerAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:registry.ServerAddress.ip)
}
inline ::std::string* ServerAddress::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:registry.ServerAddress.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerAddress::release_ip() {
  // @@protoc_insertion_point(field_release:registry.ServerAddress.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerAddress::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:registry.ServerAddress.ip)
}

// required int32 port = 2;
inline bool ServerAddress::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerAddress::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerAddress::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ServerAddress::port() const {
  // @@protoc_insertion_point(field_get:registry.ServerAddress.port)
  return port_;
}
inline void ServerAddress::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:registry.ServerAddress.port)
}

// optional int32 weight = 3;
inline bool ServerAddress::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerAddress::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerAddress::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerAddress::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 ServerAddress::weight() const {
  // @@protoc_insertion_point(field_get:registry.ServerAddress.weight)
  return weight_;
}
inline void ServerAddress::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:registry.ServerAddress.weight)
}

// -------------------------------------------------------------------

// RegisterRequest

// required string service_name = 1;
inline bool RegisterRequest::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRequest::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRequest::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
inline const ::std::string& RegisterRequest::service_name() const {
  // @@protoc_insertion_point(field_get:registry.RegisterRequest.service_name)
  return service_name_.GetNoArena();
}
inline void RegisterRequest::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:registry.RegisterRequest.service_name)
}
#if LANG_CXX11
inline void RegisterRequest::set_service_name(::std::string&& value) {
  set_has_service_name();
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:registry.RegisterRequest.service_name)
}
#endif
inline void RegisterRequest::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:registry.RegisterRequest.service_name)
}
inline void RegisterRequest::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:registry.RegisterRequest.service_name)
}
inline ::std::string* RegisterRequest::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:registry.RegisterRequest.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:registry.RegisterRequest.service_name)
  if (!has_service_name()) {
    return NULL;
  }
  clear_has_service_name();
  return service_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:registry.RegisterRequest.service_name)
}

// required .registry.ServerAddress address = 2;
inline bool RegisterRequest::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterRequest::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterRequest::clear_address() {
  if (address_ != NULL) address_->Clear();
  clear_has_address();
}
inline const ::registry::ServerAddress& RegisterRequest::_internal_address() const {
  return *address_;
}
inline const ::registry::ServerAddress& RegisterRequest::address() const {
  const ::registry::ServerAddress* p = address_;
  // @@protoc_insertion_point(field_get:registry.RegisterRequest.address)
  return p != NULL ? *p : *reinterpret_cast<const ::registry::ServerAddress*>(
      &::registry::_ServerAddress_default_instance_);
}
inline ::registry::ServerAddress* RegisterRequest::release_address() {
  // @@protoc_insertion_point(field_release:registry.RegisterRequest.address)
  clear_has_address();
  ::registry::ServerAddress* temp = address_;
  address_ = NULL;
  return temp;
}
inline ::registry::ServerAddress* RegisterRequest::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    auto* p = CreateMaybeMessage<::registry::ServerAddress>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:registry.RegisterRequest.address)
  return address_;
}
inline void RegisterRequest::set_allocated_address(::registry::ServerAddress* address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete address_;
  }
  if (address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    set_has_address();
  } else {
    clear_has_address();
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:registry.RegisterRequest.address)
}

// -------------------------------------------------------------------

// RegisterResponse

// required .registry.RegisterResponse.Status status = 1;
inline bool RegisterResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::registry::RegisterResponse_Status RegisterResponse::status() const {
  // @@protoc_insertion_point(field_get:registry.RegisterResponse.status)
  return static_cast< ::registry::RegisterResponse_Status >(status_);
}
inline void RegisterResponse::set_status(::registry::RegisterResponse_Status value) {
  assert(::registry::RegisterResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:registry.RegisterResponse.status)
}

// optional string message = 2;
inline bool RegisterResponse::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponse::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterResponse::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& RegisterResponse::message() const {
  // @@protoc_insertion_point(field_get:registry.RegisterResponse.message)
  return message_.GetNoArena();
}
inline void RegisterResponse::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:registry.RegisterResponse.message)
}
#if LANG_CXX11
inline void RegisterResponse::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:registry.RegisterResponse.message)
}
#endif
inline void RegisterResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:registry.RegisterResponse.message)
}
inline void RegisterResponse::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:registry.RegisterResponse.message)
}
inline ::std::string* RegisterResponse::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:registry.RegisterResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterResponse::release_message() {
  // @@protoc_insertion_point(field_release:registry.RegisterResponse.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:registry.RegisterResponse.message)
}

// -------------------------------------------------------------------

// UnregisterRequest

// required string service_name = 1;
inline bool UnregisterRequest::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterRequest::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterRequest::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterRequest::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
inline const ::std::string& UnregisterRequest::service_name() const {
  // @@protoc_insertion_point(field_get:registry.UnregisterRequest.service_name)
  return service_name_.GetNoArena();
}
inline void UnregisterRequest::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:registry.UnregisterRequest.service_name)
}
#if LANG_CXX11
inline void UnregisterRequest::set_service_name(::std::string&& value) {
  set_has_service_name();
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:registry.UnregisterRequest.service_name)
}
#endif
inline void UnregisterRequest::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:registry.UnregisterRequest.service_name)
}
inline void UnregisterRequest::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:registry.UnregisterRequest.service_name)
}
inline ::std::string* UnregisterRequest::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:registry.UnregisterRequest.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnregisterRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:registry.UnregisterRequest.service_name)
  if (!has_service_name()) {
    return NULL;
  }
  clear_has_service_name();
  return service_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnregisterRequest::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:registry.UnregisterRequest.service_name)
}

// required .registry.ServerAddress address = 2;
inline bool UnregisterRequest::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnregisterRequest::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnregisterRequest::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnregisterRequest::clear_address() {
  if (address_ != NULL) address_->Clear();
  clear_has_address();
}
inline const ::registry::ServerAddress& UnregisterRequest::_internal_address() const {
  return *address_;
}
inline const ::registry::ServerAddress& UnregisterRequest::address() const {
  const ::registry::ServerAddress* p = address_;
  // @@protoc_insertion_point(field_get:registry.UnregisterRequest.address)
  return p != NULL ? *p : *reinterpret_cast<const ::registry::ServerAddress*>(
      &::registry::_ServerAddress_default_instance_);
}
inline ::registry::ServerAddress* UnregisterRequest::release_address() {
  // @@protoc_insertion_point(field_release:registry.UnregisterRequest.address)
  clear_has_address();
  ::registry::ServerAddress* temp = address_;
  address_ = NULL;
  return temp;
}
inline ::registry::ServerAddress* UnregisterRequest::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    auto* p = CreateMaybeMessage<::registry::ServerAddress>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:registry.UnregisterRequest.address)
  return address_;
}
inline void UnregisterRequest::set_allocated_address(::registry::ServerAddress* address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete address_;
  }
  if (address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    set_has_address();
  } else {
    clear_has_address();
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:registry.UnregisterRequest.address)
}

// -------------------------------------------------------------------

// UnregisterResponse

// required .registry.UnregisterResponse.Status status = 1;
inline bool UnregisterResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::registry::UnregisterResponse_Status UnregisterResponse::status() const {
  // @@protoc_insertion_point(field_get:registry.UnregisterResponse.status)
  return static_cast< ::registry::UnregisterResponse_Status >(status_);
}
inline void UnregisterResponse::set_status(::registry::UnregisterResponse_Status value) {
  assert(::registry::UnregisterResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:registry.UnregisterResponse.status)
}

// -------------------------------------------------------------------

// DiscoverRequest

// required string service_name = 1;
inline bool DiscoverRequest::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscoverRequest::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscoverRequest::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscoverRequest::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
inline const ::std::string& DiscoverRequest::service_name() const {
  // @@protoc_insertion_point(field_get:registry.DiscoverRequest.service_name)
  return service_name_.GetNoArena();
}
inline void DiscoverRequest::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:registry.DiscoverRequest.service_name)
}
#if LANG_CXX11
inline void DiscoverRequest::set_service_name(::std::string&& value) {
  set_has_service_name();
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:registry.DiscoverRequest.service_name)
}
#endif
inline void DiscoverRequest::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:registry.DiscoverRequest.service_name)
}
inline void DiscoverRequest::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:registry.DiscoverRequest.service_name)
}
inline ::std::string* DiscoverRequest::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:registry.DiscoverRequest.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscoverRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:registry.DiscoverRequest.service_name)
  if (!has_service_name()) {
    return NULL;
  }
  clear_has_service_name();
  return service_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoverRequest::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:registry.DiscoverRequest.service_name)
}

// -------------------------------------------------------------------

// DiscoverResponse

// repeated .registry.ServerAddress addresses = 1;
inline int DiscoverResponse::addresses_size() const {
  return addresses_.size();
}
inline void DiscoverResponse::clear_addresses() {
  addresses_.Clear();
}
inline ::registry::ServerAddress* DiscoverResponse::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:registry.DiscoverResponse.addresses)
  return addresses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::registry::ServerAddress >*
DiscoverResponse::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:registry.DiscoverResponse.addresses)
  return &addresses_;
}
inline const ::registry::ServerAddress& DiscoverResponse::addresses(int index) const {
  // @@protoc_insertion_point(field_get:registry.DiscoverResponse.addresses)
  return addresses_.Get(index);
}
inline ::registry::ServerAddress* DiscoverResponse::add_addresses() {
  // @@protoc_insertion_point(field_add:registry.DiscoverResponse.addresses)
  return addresses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::registry::ServerAddress >&
DiscoverResponse::addresses() const {
  // @@protoc_insertion_point(field_list:registry.DiscoverResponse.addresses)
  return addresses_;
}

// -------------------------------------------------------------------

// HeartbeatRequest

// required string service_name = 1;
inline bool HeartbeatRequest::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRequest::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRequest::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRequest::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
inline const ::std::string& HeartbeatRequest::service_name() const {
  // @@protoc_insertion_point(field_get:registry.HeartbeatRequest.service_name)
  return service_name_.GetNoArena();
}
inline void HeartbeatRequest::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:registry.HeartbeatRequest.service_name)
}
#if LANG_CXX11
inline void HeartbeatRequest::set_service_name(::std::string&& value) {
  set_has_service_name();
  service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:registry.HeartbeatRequest.service_name)
}
#endif
inline void HeartbeatRequest::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:registry.HeartbeatRequest.service_name)
}
inline void HeartbeatRequest::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:registry.HeartbeatRequest.service_name)
}
inline ::std::string* HeartbeatRequest::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:registry.HeartbeatRequest.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartbeatRequest::release_service_name() {
  // @@protoc_insertion_point(field_release:registry.HeartbeatRequest.service_name)
  if (!has_service_name()) {
    return NULL;
  }
  clear_has_service_name();
  return service_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatRequest::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:registry.HeartbeatRequest.service_name)
}

// required .registry.ServerAddress address = 2;
inline bool HeartbeatRequest::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatRequest::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatRequest::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatRequest::clear_address() {
  if (address_ != NULL) address_->Clear();
  clear_has_address();
}
inline const ::registry::ServerAddress& HeartbeatRequest::_internal_address() const {
  return *address_;
}
inline const ::registry::ServerAddress& HeartbeatRequest::address() const {
  const ::registry::ServerAddress* p = address_;
  // @@protoc_insertion_point(field_get:registry.HeartbeatRequest.address)
  return p != NULL ? *p : *reinterpret_cast<const ::registry::ServerAddress*>(
      &::registry::_ServerAddress_default_instance_);
}
inline ::registry::ServerAddress* HeartbeatRequest::release_address() {
  // @@protoc_insertion_point(field_release:registry.HeartbeatRequest.address)
  clear_has_address();
  ::registry::ServerAddress* temp = address_;
  address_ = NULL;
  return temp;
}
inline ::registry::ServerAddress* HeartbeatRequest::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    auto* p = CreateMaybeMessage<::registry::ServerAddress>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:registry.HeartbeatRequest.address)
  return address_;
}
inline void HeartbeatRequest::set_allocated_address(::registry::ServerAddress* address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete address_;
  }
  if (address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    set_has_address();
  } else {
    clear_has_address();
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:registry.HeartbeatRequest.address)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// required .registry.HeartbeatResponse.Status status = 1;
inline bool HeartbeatResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::registry::HeartbeatResponse_Status HeartbeatResponse::status() const {
  // @@protoc_insertion_point(field_get:registry.HeartbeatResponse.status)
  return static_cast< ::registry::HeartbeatResponse_Status >(status_);
}
inline void HeartbeatResponse::set_status(::registry::HeartbeatResponse_Status value) {
  assert(::registry::HeartbeatResponse_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:registry.HeartbeatResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace registry

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::registry::RegisterResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::registry::RegisterResponse_Status>() {
  return ::registry::RegisterResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::registry::UnregisterResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::registry::UnregisterResponse_Status>() {
  return ::registry::UnregisterResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::registry::HeartbeatResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::registry::HeartbeatResponse_Status>() {
  return ::registry::HeartbeatResponse_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_registry_5fservice_2eproto
